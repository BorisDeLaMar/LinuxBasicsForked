# 3.3 Атрибуты создаваемого процесса. Системный вызов clone  
`clone` является более разумным аналогом `fork`. Если второй просто все копирует с родителя, то для первого можно указать, какие ресурсы будут скопированы, 
какие должны быть созданы заново, а какие-то ресурсы могут использоваться совместно с родителем.  
Например, если будем создавать потомков, использующих ту же самую память, что и родитель, то фактически мы создадим аналог потоков в Linux.
 Этот механизм и лежит в основе многопоточных приложений в Linux.  
 ## Основные атрибуты процесса (его контекст)   
 + **Открытые файлы** - когда процесс создает файлы или открывает их, создаются определенные структуры в памяти ядра, сопоставленные с этим процессом.
 Они хранятся в памяти процессов и у них есть состояние, поэтому мы должны заботиться о том, чтобы при клонировании процессов, эти файлы либо закрывались,
либо совместно использовались с родителем или еще чего. Например, не очень хорошо совместно использовать файлы ввода/вывода между родителем и потомком.  
 + **Файловые системы** - в Linux ФС монтируются в общее пространство имен. Используем `mount` для просмотра пространства имен процесса, в котором находимся.
Linux позволяет для каждого процесса, создаваемого в системе, иметь свою копию или свой конкретный экземпляр *глобального простравнства имен*.
***Для чего это нужно?*** Если у нас есть сервер с несколькими запущенными веб-сайтами, то надо, чтобы они не мешали друг другу.
Тогда создадим для каждого из этих процессов (соответствующих веб-серверам) свое пространство имен
(на самом деле указываем маленький кусочек основного пространства имен в качестве `root`, т.е. корневой ФС).
Таким образом процесс не узнает о файлах, за пределами созданной области видимости.  
 + **Операции ввода/вывода** - процесс порождает какое-то количество запросов на ввод/вывод.
Эти запросы обрабатываются *асинхронно*, поэтому если создаем копию процесса, эти операции могут остаться незавершенными и перейти в таком виде потомку.
`clone` позволяет и этот вопрос решить силами программиста, который решит, кто закончит обрабатывать эти запросы.    
 + **Сетевое окружение**
 + **Множество идентификаторов процессов**
 + **Память**
 + **Состояние регистров**
 + **Имя хоста (hostname)**

*NB В Linux процесс рассматривается как единица планирования*  
Для использования `clone` надо `#include <shed.h>` - файл, определяющий функции планировщика.  

В `clone` обязательно указываем:  
+ *функцию*, вызываемую для создаваемого потомка.
+ *область памяти стека потомка* - общий стек родителя и потомка недопустим, т.к. это 2 разные сущности, которые будут миешать друг другу в едином адресном пространстве
+ *набор флагов*, определяющих создание частей контекста потомка по родителю
## Флаги clone  
+ `CLONE_FS` -  родитель и потомок будут иметь общую информацию о ФС, будут работать в одном пространстве имен
+ `CLONE_PARENT` - родителем потомка будет не процесс, который его породил, а родитель родителя. Так можно создавать потоки приложения.  
`man clone` для просмотра всех флагов.
