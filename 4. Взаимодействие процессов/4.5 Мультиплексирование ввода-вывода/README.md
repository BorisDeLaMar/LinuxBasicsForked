# Мультиплексирование ввода-вывода  
**Мультиплексирование ввода-вывода** - механизм, позволяющий приложениям наблюдать сразу за несколькими fid (файловыми дескрипторами), не блокируясь на них.  

## Мотивационный пример  
Допустим, мы создаем чат-программу для общения двух процессов (клиент и сервер условно). Делать это будем по двум каналам, как было описано в README про каналы. 
Если мы попытаемся прочитать данные из канала, в котором их еще нет, приложение блокируется на таком вызове и ждет данных для чтения. 
Такая блокировка не позволяет нам асинхронно выполнять операции чтения и записи в несколько каналов (в одном канале заблокировались на чтении данных с сервера, 
значит не можем и послать ему данные). 

***Как решить проблему?***  
Можно создать многопоточное приложение: сделать несколько сущностей (процессов/потоков), у каждого будет собственный fid, связанный только с чтением или 
только с записью, и между этими сущностями обеспечить обмен. Но это не очень эффективно.    
Хотелось бы наблюдать за набором fid открытых и читать и писать только тогда, когда соответствующие 
объекты будут в состоянии готовности (готовы принимать или отдавать данные).  

## Пример реализации  
### Модель
Пусть у нас будет клиент с сервером, и они могут общаться по 2 именованным каналам. Рассмотрим сервер и предположим, что для него открыто несколько файлов. 
Ну, во-первых, fid = 0; 1; 2 уже заняты открытыми файлами stdin, stdout и stderr соответственно. Во-вторых же, представим что программист также написал код, из-за 
которого открылись файлы с fid = 3; 4; 5.  
Для того, чтобы работать со всеми этими fid одновременно, создадим **список наблюдения**. Он будет представлять из себя некоторый набор битовых флажков. 
В этом списке каждая позиция (бит) будет соответствовать порядковому номеру fid, который есть в нашей программе. Такой контейнер битовых флажков в Linux имеет 
тип fd_set. Смысл в следующем: установим 1 в те биты, которые соотвествуют fid, за которыми наблюдаем.  
Для манипуляций с этой строкой битов в Linux предлагается использовать несколько макросов:  
+ FD_ZERO(&watch_list) - обнулить все файлы из списка наблюдения.
+ FD_SET(fid1, &watch_list) - наблюдать за fid1
+ FD_CLR(fid1, &watch_list) - исключить fid1 из списка наблюдения

Теперь надо научиться наблюдать за файлами: в каком они состоянии (готовы работать или нет).  
Позволяет это сделать `int select(num_of_fids, fd_set_read, fd_set_write, fd_set_except, time_wait)`.  `fd_set_read, fd_set_write, fd_set_except` - наборы fid. 
`fd_set_except` - для исключительных ситуаций. `time_wait` - параметр для тех, кто не хочет ждать вечно выполнения какого-либо условия по готовности файла 
(это данные по интервалу времени ожидания). Возвращает функция кол-во fid во всех трех наборах из аргументов, которые готовы к соответствующим им операциям.  
Для того, чтобы проверить, что мы можем читать из fid1, надо воспользоваться макросом `FD_ISSET(fid1, &watch_list)`.  

Дело в том, что `select` будет заблокирована на операции наблюдения за fid до тех пор, пока какие-то из fid в этих трех наборах не станут соответствовать файлам, 
которые готовы к выполнению над ними соответствующих функций.  
Например, если мы наблюдаем за файлами для чтения, после возврата из `select` те флажки fid, которые готовы для чтения, будут = 1.  
### Пример кода работы с двумя fid  
```
#include <stdio.h>
#include <sys/select.h>
#include <unistd.h>
#include <fcntl.h>

void read_and_report(int fd)
{
  char buf[100];
  printf("FD %d is ready to read\n", fd);
  int bytes = read(fd, buf, 100);
  buf[bytes] = 0;
  printf("Get %d bytes from %d : %s\n", bytes, fd, buf);
}

int main()
{

  int f1 = open ("./f1.fifo", O_RDWR);
  int f2 = open ("./f2.fifo", O_RDWR);

  if (!(f1 && f2) ) 
  {
    printf ("Error with opening pipes\n");
    return 0;
  }

  printf("Descriptors: %d %d\n", f1, f2);

  fd_set read_set;

  while(1)
  {
    FD_ZERO(&read_set);
    FD_SET(f1, &read_set);
    FD_SET(f2, &read_set);
    int result = select(f2+1, &read_set, NULL, NULL, NULL);
    
    if(result)
    {
      if( FD_ISSET(f1, &read_set) )
        read_and_report(f1);
      if( FD_ISSET(f2, &read_set) )
        read_and_report(f2);
    }
  }
  return 0;
}
```
Такая программа будет ссобщать нам каждый раз, когда что-то записано в один из соответсвующих файлов.
