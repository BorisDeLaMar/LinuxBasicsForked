# 2.5 Отладка программ в Linux

## Вывод отладочной информации  
По умолчанию отладочной информации выводится немного и отладчику не удастся найти те символические имена и те исходные тексты программ, которые стали источником исполняемого модуля.  
Ключи компилятора gcc для включения расширенной дебаг информации 
+ `gcc -g<0,1,2,3>` - задает уровень отладки
+ `gcc -o<0,1,2,3>` - задает уровень оптимизации
+ `gcc -ggdb` - модификация ключа -g. Явно говорит компилятору, что отладочная инфа будет использована отладчиком GDB.

## Запуск отладчика GDB  
+ `gdb ./progname`
+ `gdb ./progname -c core` - если есть некоторый *core dumb*(образ памяти в момент краха процесса), то можно с ключом `-c` указать имя файла, с этим core dump. Тогда gdb загрузит этот файл в память и восстановит образ памяти в тот момент, когда процесс был уничтожен/этот core-файл был создан
+ `gdb ./progname -pid process-id` - указываем дополнительно идентификатор процесса, если хотим сразу подлкючиться к работающему процессу. Такое подключение возможно только если достаточно прав на это(либо gdb является отладчиком этого процесса, либо если делаем это от `root`.
`ulimit -c unlimited` - системная утилита ulimit позволяет этой командой включить автоматическое создание core-файлов  
## Получение информации в GDB  
+ `help <command>` - получение справочной информации о любой, доступной в GDB команде
+ `info args/breakpoints/watchpoints/registers/threads/signals` - информация о соответствующих штуках
+ `where` - аналог `backtrace` - показывает как выглядит стек вызова, и где мы в нем находимся
## Исполнение исполняемого файла  
+ `r/run arguments` - запуск программы с аргументами(опционально) как из консоли, если их требует на ввод программа
+ `c/continue` - продолжает исполнение приложения, если была точка остановки
+ `continue number` - продолжение исполнения программы с игнорированием number точек остановки
+ `finish` - запускает программное исполнение до конца текущей функции
+ `kill` - убивает приложение
+ `quit` - выход из режима отладки
## Исполнение по шагам  
+ `step` - ходим по коду построчно
+ `next` - переход на следующую линию исходного кода
+ `until line-number` - шагать до достижения какой-то линии кода
+ `stepi/nexti` - ходить по ассемблерным инстуркциями
## Управление breakpoints  
+ `break function/line` - установка breakpoint
+ `break +/- number-of-lines` - установка brekpoint сверху/снизу
+ `break filename:function`
+ `break *instruction_address`
+ `break ... if condition` - применимо, напрмиер, в цикле. Можно ставить breakpoint на конкретное значение итератора
+ `break line thread tid` - для многопоточных приложений
+ `clear`
+ `enable/disable`
+ `watch condition` - просмотреть значение того или иного выражения
## Инспектирование стека  
+ `bt/backtrace` - выводит список стековых кадров и наше в нем расположение
+ `f/frame number/up/down` - перемещение по стеку
+ `backtrace full`
+ `up/down number`
+ `info frame`
## Просмотр исходного текста программы и печать переменных  
+ `list [+n | -n]` - вывод `n` строк до или после точки остановки
+ `set listsize num` - можем регулировать кол-во выводимого командой `list`
+ `list start,end`
+ `p/print variable`
+ `p/[format] variable` - вывод переменной в определенном формате: `x/o/d/f/c`. `o` для вывода в 8-ричном виде, например

*NB Segmentation fault (core dumped) означает, что создался файл с core dump*  
*NBB Чаще всего IDE используют системные отладчики(такие как gdb в Линуксе). То есть, просто знают как ими пользоваться и надстаривают над ними функционал*
