# Файловая система /proc. Построение дерева  

Для того, чтобы обнаружить, какие вызовы из библиотеквыполняет наше приложение и какие системные вызовы выполняет приложение вместе с библиотеками, используются утилиты:  
+ `ltrace` - library trace - полволяет отслеживать все вызовы в бибиотеке
+ `strace` - system calls trace- позволяет таким же образом отслеживать системные вызовы 
## Драйвер файловой системы, связанный с памятью на диске   
***Что происходит, когда пытаемся записать/прочитать какой-то файл в файловой системе?***  
Ядро ОС отделено от пользовательского приложения(далее *ПП*). В ПП пишем `printf`, далее с помощью различных библиотек эта команда транслируется в системный вызов - `write`, который предоставляется ядром в виде условного `sys_write(fid, ..)`.  
***Но откуда fid, если вывод в консоль?***  
На самом деле, он возник в тот момент, когда открывался стандартный файл для вывода(файл консоли). В таком случае очевидно, что есть и `sys_open` или `sys_creat`(в ядре она именно что без `e` на конца).    
***Что же в таком случае происходит в sys_open и каким образом назначается файловый дескриптор?***  
У ОС в распоряжении есть либо HDD, либо SDD, обслуживаемый *драйвером*(специальная программа, осуществляющая абстракцию оборудования или протокола). Также имеем *драйвера файловых систем*(их может быть несколько).  
NB У Линукс единая иерархия имен, независимо от того, какие устройства(а вместе с ними и фаловые системы) лежат за этими именами.  
Так вот, обработчик системного вызова `sys_open` может по передаваемому в `sys_open` имени определить, какому именно драйверу относится это имя. К нему `sys_open` и обратится. Он, в свою очередь, глядя на это имя может читать с диска(с помощью драйвера диска) информацию о структуре хранимых данных там(метаинформация).  
По этой информации файловая система(далее ФС) может связать вновь создаваемый **идентификатор открытого файла(fid)** с каким-то конкретным **Inode**.  
То есть, если из `sys_open` мы попали в драйвер ФС, то в памяти процесса, вызывающего `sys_open`, образуется **связка** между выданным **fid** и конкретным **Inode**.  
## Драйвер ФС, связанный с памятью процессов  
***Как можно использовать файловый интерфейс и sys calls для обращения в память ядра?***    
Пусть у нас есть драйвер специальной ФС. В нашем случае это **procfs**(ФС процессов). Вызов `sys_open` будем перенаправлять в этот драйвер, а он, соответственно, будет иметь доступ к структурам, находящимся в памяти ядра и связанным с процессами.  
То есть, драйвер может осуществлять доступ к этим структурам и сопоставлять имена, которые мы имеем в `userspace`.  
NB Для procfs в `userpace` все имена начинаются с `/proc/` и могут быть либо `/proc/file`, либо `/proc/PID/file`, где PID - каталог, содержащий файлы, относящиеся к определенному процессу  
**Итого:** используя системный вызов `sys_open` мы можем создавать **ассоциацию** между именем **в пространстве пользователя**, некоторым **идентификатором процесса** и **файловым дескриптором**.  
Как только появляется ассоциация между fid и конкретным процессом, можем спокойно выполнять `sys_write(fid)` или `sys_read(fid)` через пользоватеьские команды(например, `printf` или `gets`).  
Естесственно, эти `sys` также будут обращаться к структурам, находящимся в памяти ядра, которые представляют атрибуты конкретного процесса.  
## Монтирование  
Для того, чтобы организовать файлы, хранящиеся в разных ФС в виде единой иерархии, производится операция **монтирования**. Это значит, что имеется какой-то общий *корень*(в Линуксе его обычное имя - "/"), и начиная от этого корня можем **монтировать** различные ФС.  
Как правило, есть **корневая ФС**, которая монтируется по основному корню пространства имен файлов, а дальше в различные катологи этого корневого пространства имен можем *монтировать другие ФС*.  
Для просмотра текущих точек монтирования в Линуксе можно воспользоваться утилитой `mount`.  
## Практическая информация  
Если зайти в `/proc` и сделать `ll`, можно будет увидеть много папок с числовыми именами. Это *номера текущих процессов*.  
`echo $$` покажет номер текущего процесса, по которому можно перейти в папку с этим процессом. В этой папке есть несколько интересных файлов:  
+ comm - имя exe-шника
+ cmdline - имя команды, запустившей процесс, насколько я понял
+ cwd - хранит информацию о текущем каталоге процесса  
+ environ - состав текущих переменных окружения, с которыми работает данный процесс    
+ limits - ограничения, заданные процессу  
+ ns - namespace - пространство имен  
+ stat и status - статистика в нечитаемом и читаемом виде соответственно  
+ cpuinfo - информация о процессорах(о каждом ядре в отдельном блоке), независимо от того, сколько из них используется процессом  
NB Информация в ФС `/proc` динамически меняется. На самом деле она нигде не хранится, кроме операционной памяти, и по запросам типо `cat cwd` драйвер ФС доставляет информацию в `userspace`.  
 
